<html>
	<head>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML'></script>
		<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
		<style>
			h1 {
				text-align: center;
			}

			.container {
				margin: 0 auto;
				padding: 60px 20%;
			}

			figure {
				text-align: center;
			}

			img {
				display: inline-block;
			}

			body {
				font-family: 'Inter', sans-serif;
			}
		</style>
	</head>
	<body>
		<div class="container">
		<h1>CS184/284A Spring 2025 Homework 2 Write-Up</h1>
		<div style="text-align: center;">Names: </div>

		<br>

		Link to webpage: <a href="https://cal-cs184-student.github.io/hw-webpages-frame-drop-fam-1/hw2/index.html">https://cal-cs184-student.github.io/hw-webpages-frame-drop-fam-1/hw2/index.html</a>

		<br>
		
		Link to GitHub repository: <a href="https://github.com/cal-cs184-student/sp25-hw2-frame-drop-fam-v2">https://github.com/cal-cs184-student/sp25-hw2-frame-drop-fam-v2</a>

		<!--
		We've already added one heading per part, to make your write-up as navigable when grading. Please fit your write-up within these sections!
		-->

		<h2>Overview</h2>
		Give a high-level overview of what you implemented in this homework. Think about what you've built as a whole. Share your thoughts on what interesting things you've learned from completing the homework.

		<h2>Section I: Bezier Curves and Surfaces</h2>

		<h3>Part 1: Bezier curves with 1D de Casteljau subdivision</h3>
		<p>
			de Casteljau's algorithm starts with recursively calculating the intermediary control points from the original control points \( \mathbf{b}_0, \dots, \mathbf{b}_n \) all the way down to a single point by linearly interpolating each pair of adjacent points and finding the point \( t \) along the line segment. We label the intermediary control points \( \mathbf{b}_i^k \), where \( i \) is the index of the intermediary point at that level and \( k \) is the recursive level the intermediary point is on, where the original control points are considered level \( 0 \). Therefore, \( 0 \le k \le n \). The math for the linear interpolation can be represented with the equation:

			\[ \mathbf{b}_i^k = lerp(\mathbf{b}_i^{k-1}, \mathbf{b}_{i+1}^{k-1}, t) = (1 - t)\mathbf{b}_i^{k-1} + t \mathbf{b}_{i+1}^{k-1} \]

			To find the Bezier curve using the intermediary control points, we recursively calculate \( \mathbf{b}_i^k(t) = (1 - t)\mathbf{b}_i^{k-1} + t \mathbf{b}_{i+1}^{k-1} \) to find \( \mathbf{b}^n(t) = \mathbf{b}_0^n(t) \), the Bezier curve. This algorithm can also be represented using the Bernstein polynomial:

			\[ \mathbf{b}^n(t) = \mathbf{b}_0^n(t) = \sum\limits_{j=0}^n \mathbf{b}_j B_j^n(t) \]

			The Bernstien polynomial \( B_j^n(t) \) is defined to be:

			\[ B_i^n(t) = \binom{n}{i} t^i (1 - t)^{n-i} \]

			This is just the binomial formula applied to reduce the paths of the recursion calculation.
		</p>
		<p>
			We created a Bezier curve with the following six control points.
		</p>
		<div style="display: flex; flex-direction: column; align-items: center; margin: 10px;">
			<img src="part1/1a.png" width="400px"/>
			<figcaption>Six Control Points with the Bezier Curve</figcaption>
		</div>
		<p>
			Each intermediary level is shown below with the Bezier Curve in green:
		</p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: separate; border-spacing: 20px;">
					<tr>
							<td style="text-align: center; padding: 10px;">
									<img src="part1/1b.png" width="400px"/>
									<figcaption>Level 1</figcaption>
							</td>
							<td style="text-align: center; padding: 10px;">
									<img src="part1/1c.png" width="400px"/>
									<figcaption>Level 2</figcaption>
							</td>
							<td style="text-align: center; padding: 10px;">
									<img src="part1/1d.png" width="400px"/>
									<figcaption>Level 3</figcaption>
							</td>
					</tr>
					<tr>
							<td style="text-align: center; padding: 10px;">
									<img src="part1/1e.png" width="400px"/>
									<figcaption>Level 4</figcaption>
							</td>
							<td style="text-align: center; padding: 10px;">
									<img src="part1/1f.png" width="400px"/>
									<figcaption>Level 5</figcaption>
							</td>
							<td style="text-align: center; padding: 10px;">
									<img src="part1/1g.png" width="400px"/>
									<figcaption>Level 6</figcaption>
							</td>
					</tr>
			</table>
		</div>
		<p>
			Here is a different Bezier curve with the control points moved and the \( t \) value increased.
		</p>
		<div style="display: flex; flex-direction: column; align-items: center; margin: 10px;">
			<img src="part1/1h.png" width="400px"/>
			<figcaption>Six Different Control Points with a larger \( t \)</figcaption>
		</div>

		<h3>Part 2: Bezier surfaces with separable 1D de Casteljau</h3>
		<p>
			To extend the de Casteljau algorithm to Bezier suraces with a \( n \times n \) grid of control points, we can use the 1D de Casteljau algorithm in both directions independently to sample any point within the grid. Instead of having a single parameter \( t \), we have two parameters \( u \) and \( v \), one in the row direction and the other in the column direction respectively. To sample the surface at the point \( (u, v) \) (where both parameters lie in the range \( [0, 1] \)), we first apply the 1D de Casteljau algorithm on each row with parameter \( u \) to get the final point on each row, then apply the 1D de Casteljau algorithm to all of these points with parameter \( v \). Note that we calculate the row direction first, then the column direction, because the 2D de Casteljau algorithm is seperable.
		</p>
		<p>
			Our evaluated teapot using our implementation is shown below.
		</p>
		<div style="display: flex; flex-direction: column; align-items: center; margin: 10px;">
			<img src="part2/2.png" width="400px"/>
			<figcaption>Bezier Surface of the Teapot</figcaption>
		</div>

		<h2>Section II: Triangle Meshes and Half-Edge Data Structure</h2>

		<h3>Part 3: Area-weighted vertex normals</h3>
		<p>
			To calculate the area-weighted vertex normals, we average the normals of each face that includes the vertex weighted by the area of that face. The <code>Face::normal()</code> function implements the face normal weighted by the area already. This function calculates the face normal weighted by the area by taking each edge and computing the cross product of its two vertices, then summing all of these cross products. This naturally gives the normal multiplied by the area of the face.
		</p>
		<p>
			The teapot shaded using flat shading and Phong shading (shading using vertex normals) is shown below.
		</p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: separate; border-spacing: 20px;">
					<tr>
							<td style="text-align: center; padding: 10px;">
									<img src="part3/3a.png" width="400px"/>
									<figcaption>Teapot with Flat Shading</figcaption>
							</td>
							<td style="text-align: center; padding: 10px;">
									<img src="part3/3b.png" width="400px"/>
									<figcaption>Teapot with Phong Shading</figcaption>
							</td>
					</tr>
			</table>
		</div>

		<h3>Part 4: Edge flip</h3>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<h3>Part 5: Edge split</h3>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<h3>Part 6: Loop subdivision for mesh upsampling</h3>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<h2>(Optional) Section III: Potential Extra Credit - Art Competition: Model something Creative</h2>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<h2>Additional Notes (please remove)</h2>
		<ul>
			<li>You can also add code if you'd like as so: <code>code code code</code></li>
			<li>If you'd like to add math equations, 
				<ul>
					<li>You can write inline equations like so: \( a^2 + b^2 = c^2 \)</li>
					<li>You can write display equations like so: \[ a^2 + b^2 = c^2 \]</li>
				</ul>
			</li>
		</ul>
		</div>
	</body>
</html>