<html>
	<head>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML'></script>
		<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
		<style>
			h1 {
				text-align: center;
			}

			.container {
				margin: 0 auto;
				padding: 60px 20%;
			}

			figure {
				text-align: center;
			}

			img {
				display: inline-block;
			}

			body {
				font-family: 'Inter', sans-serif;
			}
		</style>
	</head>
	<body>
		<div class="container">
		<h1>CS184/284A Spring 2025 Homework 2 Write-Up</h1>
		<div style="text-align: center;">Names: </div>

		<br>

		Link to webpage: <a href="https://cal-cs184-student.github.io/hw-webpages-frame-drop-fam-1/hw2/index.html">https://cal-cs184-student.github.io/hw-webpages-frame-drop-fam-1/hw2/index.html</a>

		<br>
		
		Link to GitHub repository: <a href="https://github.com/cal-cs184-student/sp25-hw2-frame-drop-fam-v2">https://github.com/cal-cs184-student/sp25-hw2-frame-drop-fam-v2</a>

		<!--
		We've already added one heading per part, to make your write-up as navigable when grading. Please fit your write-up within these sections!
		-->

		<h2>Overview</h2>
		Give a high-level overview of what you implemented in this homework. Think about what you've built as a whole. Share your thoughts on what interesting things you've learned from completing the homework.

		<h2>Section I: Bezier Curves and Surfaces</h2>

		<h3>Part 1: Bezier curves with 1D de Casteljau subdivision</h3>
		<p>
			de Casteljau's algorithm starts with recursively calculating the intermediary control points from the original control points \( \mathbf{b}_0, \dots, \mathbf{b}_n \) all the way down to a single point by linearly interpolating each pair of adjacent points and finding the point \( t \) along the line segment. We label the intermediary control points \( \mathbf{b}_i^k \), where \( i \) is the index of the intermediary point at that level and \( k \) is the recursive level the intermediary point is on, where the original control points are considered level \( 0 \). Therefore, \( 0 \le k \le n \). The math for the linear interpolation can be represented with the equation:

			\[ \mathbf{b}_i^k = lerp(\mathbf{b}_i^{k-1}, \mathbf{b}_{i+1}^{k-1}, t) = (1 - t)\mathbf{b}_i^{k-1} + t \mathbf{b}_{i+1}^{k-1} \]

			To find the Bezier curve using the intermediary control points, we recursively calculate \( \mathbf{b}_i^k(t) = (1 - t)\mathbf{b}_i^{k-1} + t \mathbf{b}_{i+1}^{k-1} \) to find \( \mathbf{b}^n(t) = \mathbf{b}_0^n(t) \), the Bezier curve. This algorithm can also be represented using the Bernstein polynomial:

			\[ \mathbf{b}^n(t) = \mathbf{b}_0^n(t) = \sum\limits_{j=0}^n \mathbf{b}_j B_j^n(t) \]

			The Bernstien polynomial \( B_j^n(t) \) is defined to be:

			\[ B_i^n(t) = \binom{n}{i} t^i (1 - t)^{n-i} \]

			This is just the binomial formula applied to reduce the paths of the recursion calculation.
		</p>
		<p>
			We created a Bezier curve with the following six control points.
		</p>
		<div style="display: flex; flex-direction: column; align-items: center; margin: 10px;">
			<img src="part1/1a.png" width="400px"/>
			<figcaption>Six Control Points with the Bezier Curve</figcaption>
		</div>
		<p>
			Each intermediary level is shown below with the Bezier Curve in green:
		</p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: separate; border-spacing: 20px;">
					<tr>
							<td style="text-align: center; padding: 10px;">
									<img src="part1/1b.png" width="400px"/>
									<figcaption>Level 1</figcaption>
							</td>
							<td style="text-align: center; padding: 10px;">
									<img src="part1/1c.png" width="400px"/>
									<figcaption>Level 2</figcaption>
							</td>
							<td style="text-align: center; padding: 10px;">
									<img src="part1/1d.png" width="400px"/>
									<figcaption>Level 3</figcaption>
							</td>
					</tr>
					<tr>
							<td style="text-align: center; padding: 10px;">
									<img src="part1/1e.png" width="400px"/>
									<figcaption>Level 4</figcaption>
							</td>
							<td style="text-align: center; padding: 10px;">
									<img src="part1/1f.png" width="400px"/>
									<figcaption>Level 5</figcaption>
							</td>
							<td style="text-align: center; padding: 10px;">
									<img src="part1/1g.png" width="400px"/>
									<figcaption>Level 6</figcaption>
							</td>
					</tr>
			</table>
		</div>
		<p>
			Here is a different Bezier curve with the control points moved and the \( t \) value increased.
		</p>
		<div style="display: flex; flex-direction: column; align-items: center; margin: 10px;">
			<img src="part1/1h.png" width="400px"/>
			<figcaption>Six Different Control Points with a larger \( t \)</figcaption>
		</div>

		<h3>Part 2: Bezier surfaces with separable 1D de Casteljau</h3>
		<p>
			To extend the de Casteljau algorithm to Bezier suraces with a \( n \times n \) grid of control points, we can use the 1D de Casteljau algorithm in both directions independently to sample any point within the grid. Instead of having a single parameter \( t \), we have two parameters \( u \) and \( v \), one in the row direction and the other in the column direction respectively. To sample the surface at the point \( (u, v) \) (where both parameters lie in the range \( [0, 1] \)), we first apply the 1D de Casteljau algorithm on each row with parameter \( u \) to get the final point on each row, then apply the 1D de Casteljau algorithm to all of these points with parameter \( v \). Note that we calculate the row direction first, then the column direction, because the 2D de Casteljau algorithm is seperable.
		</p>
		<p>
			Our evaluated teapot using our implementation is shown below.
		</p>
		<div style="display: flex; flex-direction: column; align-items: center; margin: 10px;">
			<img src="part2/2.png" width="400px"/>
			<figcaption>Bezier Surface of the Teapot</figcaption>
		</div>

		<h2>Section II: Triangle Meshes and Half-Edge Data Structure</h2>

		<h3>Part 3: Area-weighted vertex normals</h3>
		<p>
			To calculate the area-weighted vertex normals, we average the normals of each face that includes the vertex weighted by the area of that face. The <code>Face::normal()</code> function implements the face normal weighted by the area already. This function calculates the face normal weighted by the area by taking each edge and computing the cross product of its two vertices, then summing all of these cross products. This naturally gives the normal multiplied by the area of the face.
		</p>
		<p>
			The teapot shaded using flat shading and Phong shading (shading using vertex normals) is shown below.
		</p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: separate; border-spacing: 20px;">
					<tr>
							<td style="text-align: center; padding: 10px;">
									<img src="part3/3a.png" width="400px"/>
									<figcaption>Teapot with Flat Shading</figcaption>
							</td>
							<td style="text-align: center; padding: 10px;">
									<img src="part3/3b.png" width="400px"/>
									<figcaption>Teapot with Phong Shading</figcaption>
							</td>
					</tr>
			</table>
		</div>

		<h3>Part 4: Edge flip</h3>
		<p>
			To flip an edge, we change the \( (b, c) \) edge to the \( (a, d) \) edge by replacing the correct iterators. We have to change every half-edge to point to the new next half-edge and ensure the face half-edge iterators point to a half-edge actually corresponding to the new faces. We don't have to change the \( a \) and \( d \) vertex half-edge iterators since we are only adding a half-edge to those vertices, but we do have to change the \( b \) and \( c \) half-edge iterators since they may point to the half-edges on the \( (b, c) \) edge. The half-edges on the \( (b, c) \) edge also have to have their vertices and faces changed to reflect the new mesh. None of the edge half-edge iterators have to be changed. If the edge is a boundary edge, we immediately returned the original edge without changing anything. To keep everything neat, we organized the lines of code in groups to extract the half-edges and the faces, then changed all of the iterators mentioned above. For iterators that did not change in the half-edges, we passed in references to its own values to make it clear in the code what is being updated and what is not. This resulted in everything (luckily) working the first time!
		</p>
		<p>
			The teapot in its original form and with a bunch of edges flipped is shown below. The edges that were flipped that would not change the geometry continue to have the same shading, while the edges that were flipped that would change the geometry have different shading corresponding to the new geometry.
		</p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: separate; border-spacing: 20px;">
					<tr>
							<td style="text-align: center; padding: 10px;">
									<img src="part4/4a.png" width="400px"/>
									<figcaption>Original Teapot</figcaption>
							</td>
							<td style="text-align: center; padding: 10px;">
									<img src="part4/4b.png" width="400px"/>
									<figcaption>Teapot with Edges Flipped</figcaption>
							</td>
					</tr>
			</table>
		</div>

		<h3>Part 5: Edge split</h3>
		<p>
			To split an edge, we take the midpoint of a given edge \( (b, c) \) and split the two faces adjacent to this edge using the midpoint \( m \) as a new vertex, connecting it to vertices \( a \) and \( d \). Our implementation changes the two faces to correspond to the \( (a, m, c) \) and \( (c, m, d) \) faces and changes the \( (b, c) \) edge to the \( (m, c) \) edge. We create the other new edges and half-edges containing the new vertex \( m \) and the two new \( (a, m, b) \) and \( (b, m, d) \) faces. The only old vertex that needs to be changed is \( b \), as it is the only vertex that is losing a half-edge. With our implementation, none of the old edges have to change, but the old faces have to change to make sure they don't point to the wrong half-edges. Then we need to change all of the half-edges to their updated next half-edges, new twin half-edges, new vertices, new edges, and new faces. The only half-edge that actually doesn't have to change is the half-edge pointing from vertex \( d \) to vertex \( c \). Like part 4, we systematically got the references to all of the half-edges, vertices, and faces and changed all of the iterators described. We also systematically created the new iterators in the mesh. When updating the half-edges, we organized it by face. As we did in part 4, for iterators that did not change in the half-edges, we passed in references to its own values to make it clear in the code what is being updated and what is not. This again resulted in everything (luckily) working the first time!
		</p>
		<p>
			The teapot in its original form, with some edge splits, and with both edge splits and edge flips is shown below. The edge splits without edge flips do not significantly change the geometry of the teapot, so it is hard to notice shading changes with only the edge splits. With both edge splits and edge flips, we can see more unique shading patterns by flipping new mesh patterns created by splitting edges.
		</p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: separate; border-spacing: 20px;">
					<tr>
							<td style="text-align: center; padding: 10px;">
									<img src="part5/5a.png" width="400px"/>
									<figcaption>Original Teapot</figcaption>
							</td>
							<td style="text-align: center; padding: 10px;">
									<img src="part5/5b.png" width="400px"/>
									<figcaption>Teapot with Edges Split</figcaption>
							</td>
							<td style="text-align: center; padding: 10px;">
								<img src="part5/5c.png" width="400px"/>
								<figcaption>Teapot with Edges Split and Flipped</figcaption>
						</td>
					</tr>
			</table>
		</div>

		<h3>Part 6: Loop subdivision for mesh upsampling</h3>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<h2>(Optional) Section III: Potential Extra Credit - Art Competition: Model something Creative</h2>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<h2>Additional Notes (please remove)</h2>
		<ul>
			<li>You can also add code if you'd like as so: <code>code code code</code></li>
			<li>If you'd like to add math equations, 
				<ul>
					<li>You can write inline equations like so: \( a^2 + b^2 = c^2 \)</li>
					<li>You can write display equations like so: \[ a^2 + b^2 = c^2 \]</li>
				</ul>
			</li>
		</ul>
		</div>
	</body>
</html>